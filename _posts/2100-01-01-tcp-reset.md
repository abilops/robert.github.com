---
layout: post
title: TCP Reset Attack
tags: [Security]
published: false
---

An efficient circumvention method is to ignore the reset packet sent by the firewall.[55] a patch for FreeBSD has been developed for this purpose.[56]
https://en.wikipedia.org/wiki/Great_Firewall#Blocking_methods

A practical guide to TCP reset attacks
How to TCP reset attack yourself
A TCP reset attack lab
TCP reset attacks: theory and practice

# What is the point of this post?
Show you how to do TCP reset
Teach you the details of TCP reset
Teach you the basics of TCP reset

History of TCP reset and mitigations

What should the title convey?
This actually shows you how to do one
Contains details
Contains beginners guide

Could do the TCP guide first
I'm a little loathe to do a full TCP guide at this point
Could just make a little tool to analyze TCP conversations
Not aiming to fully understand everything - just clearly describe the simple cases

Analyzing real TCP conversations
Explain the basics of TCP but don't go into window sizes or other fancy things
Don't say "this assumes knowledge of". Just say "this won't tell you about the fancy bits"

Understanding TCP by analyzing real connections

tcp-conversational - a tool to help you understand the TCP protocol by analyzing real connections

The goal of this post is to help you fully understand the central ideas of TCP
This means sequence numbers, acks, and flags
We won't talk about window sizes or edge cases
We'll just fully understand how TCP creates a realiable stream of data over an unreliable network
Also how TCP relates to IP etc

We'll do this using tcp-conversational, a simple tool
It's like Wireshark and tcpdump, but with most of the details removed and formatted so as to make understanding the conversation easier



# OSI model
https://tools.ietf.org/html/rfc3439#section-3
The separation is not complete, which makes thinking about it a bit harder but makes the product better
Reasonable to start by assuming that the layers are perfect abstractions

Each layer is built on top of the layer before it
Presents a new layer to those that come after it so that (in theory) these layers don't have to worry about the ones before

Maybe this should be a post of its own?

TCP Reset Attacks, Chapter 1: The OSI and TCP/IP models

TCP Reset Attacks, Chapter 1: Why does TCP exist?

TCP Reset Attacks, Chapter 1: What does TCP do?
TCP Reset Attacks, Chapter 2: How does TCP work?
TCP Reset Attacks, Chapter 3: The attack

Then:

tcp-conversational - learn about the TCP protocol by analyzing real connections

========

The transport layer is responsible for delivering data to the appropriate application process on the host computers. 
https://en.wikipedia.org/wiki/Transport_layer

Note: GFW does prevent point to point communication from users who they TCP reset attcak, so that is possible



DEF MAKE A VIDEO OF THIS

====

The TCP reset attack is a great attack. It is conceptually simple, while also teaching you a great deal about the particulars of the TCP protocol itself. Fear of the attack has resulted in changes being made to the TCP protocol that partially mitigate it. TCP reset attacks are believed to be a key component in China's Great Firewall (GFW) that censors the internet inside China. But you can still safely execute the attack against yourself using only your laptop.

In this post we'll:

* Learn the basics of TCP
* Learn how the TCP reset attack works
* See how the attack is used in the Great Firewall
* Execute the attack against ourselves using a simple Python script

TODO - table of contents


----

## Intoduction to the Great Firewall

The Great Firewall (GFW) is a collection of systems and techniques that are used by the Chinese government to censor the internet for users inside China. The GFW monitors internet traffic on networks inside China, as well as blocking and killing connections to servers inside and outside of the country.

The GFW uses several techniques to prevent users from even making contact with forbidden servers. Two such techniques are *DNS pollution* and *IP blocking*. In DNS pollution, the GFW interferes with DNS, the process by which computers translate URLs (like `robertheaton.com`, which the internet backbone does not understand) into IP addresses (like `104.18.32.191`). This prevents users' devices from discovering which IP address they should send their traffic to for a given domain.

However, even if a user is able to resolve a domain to an IP address, they may still be prevented from talking to the address by the GFW's IP blocking program. The government maintains a hardcoded list of forbidden IP addresses, and forces Chinese Internet Service Providers (ISPs) to "blackhole" traffic headed to those IP addresses.

DNS pollution and IP blocking both rely on the government being able to interfere with a connection before it has even begun. However, the government may also sometimes want to allow a connection to be made, but then to kill it halfway through. This could be because they want to perform slower analysis on the connection, such as correlating it with other activity, or because they want to analyze the data exchanged over a connection and use this to device whether to allow or block its traffic. For example, they may want to generally allow traffic to a news website, but to block specific videos containing banned keywords.

However, neither IP blocking nor DNS pollution are suitable for killing an already-established connection. If a connection has already been opened then the client must have already resolved their target domain into an IP address, and so do not need to make any more DNS requests. DNS pollution is therefore unhelpful. And it is both infeasible and undesirable for dynamic updates to the IP blocklist to be pushed out fast enough to block a connection that is already in progress.

The government therefore needs a more surgical tool, one that is capable of killing already-established connections. The tool that they use is the TCP reset attack.

## How does a TCP reset attack work?

In a TCP reset attack, an attacker kills a connection between two victims by sending one or both victims fake packets of data saying that the other party has terminated the connection. These packets are called *TCP reset segments*. If a fake TCP reset segment is crafted correctly, the receiver will accept it as valid and close their side of the connection, preventing further information from being exchanged over it. The victims can create a new TCP connection to attempt to resume their communications, but the attacker may be able to reset that connection too. So if the GFW decides that it wants to kill a TCP connection, it can do so by firing out spoofed TCP reset segments, causing one or both sides of the connection to terminate it.

### Is a TCP reset attack difficult to execute?

A TCP reset attack is conceptually simple, but in practice can be challenging to pull off. In order to see why, we'll need to understand how the TCP protocol works. We'll study it in much more detail in part 3.

A TCP *stream* is a flow of data, in the same form that the sender sent it. For example, if my server sends your computer the HTML for this website over a TCP stream, your computer will receive that HTML in the exact form and order that my server sent it.

[TODO-PIC]

However, the HTML is not sent over the internet in this perfect, consistent form. Instead, it is broken up into many small chunks (known as *TCP segments*), which are sent separately over the internet and reconstituted into a contiguous piece of data by your computer's TCP stack.

[TODO-PIC]

This is a difficult task, because the internet is not reliable. TCP segments may get lost; arrive out of order; be sent twice; get corrupted; or have any number of other mishaps befall them. The job of the TCP protocol is therefore to provide reliable communication over an unreliable network. It achieves this goal by requiring the two sides of a connection to keep in close contact with each other, constantly reporting which segments they have received. This allows a sender to infer which segments a receiver has not yet received, and to re-send those that may have been lost.

Segments are identified and tracked by their *sequence number*. Every segment has a sequence number, assigned to it by the sender. When two machines are negotiating a TCP connection, each machine assigns to the first segment that it sends a random *initial sequence number*. Every subsequent segment sent by that machine is assigned a sequence number equal to the sequence number of the previous segment, plus the number of bytes of data in the previous segment [TODO?]. Receiving machines use sequence numbers to reconstruct the segments they receive into their original order.

[TODO-PIC]

When a machine receives a TCP segment, it notifies the segment's sender that it has received it. It does so by sending an `ACK` (should for acknowledge) segment, containing the sequence number of the *next* segment that it expects to receive. The sender can assume that the receiver has received all segments up to this number. The TCP protocol also allows for *selective ACKs*, which are sent when a receiver has received some, but not all, segments in a range. For example "I've received segments 1000,2000,4000 and 5000, but not 3000". For simplicity, we will ignore selective ACKs in our discussion of the TCP reset attacks.

If a sender sends a packet but does not receive an `ACK` for it within a certain time window, the sender simply resends it. The re-sent segment has the same sequence number as the original. This means that if the receiver receives two copies of the same segment, it can trivially de-duplicate them without corrupting the stream. A receiver might receive duplicate segments if an original segment arrives late, after it has been re-sent, or if the original segment had already arrived but the receiver's `ACK` segment got lost on its way to the sender.

So long as such duplicate segments are relatively infrequent, the overhead that they cause is unproblematic. If all segments eventually reach their receiver, and the corresponding `ACK`s eventually reach their sender, the TCP connection will work.

### What sequence numbers are acceptable for a `RST` segment?

It is easy to send spoofed TCP `RST` segments. Neither TCP nor IP comes with any built-in way to verify a sender's identity. All a receiver can do is to take the source IP address and port inside a packet or segment at face value. Internet service providers are supposed to refuse to transit IP packets that claim to have come from a clearly-spoofed IP address, but such verification is anecdotally rare. Validation is typically left to the higher-level protocols, such as TLS[TODO].

The attacker's challenge therefore lies in giving their spoofed `RST` packets a sequence number that is acceptable to the receiver. As we've discussed, the TCP protocol is designed to account for the fact that segments might arrive out of order. Receivers are happy to accept segments with non-sequential sequence numbers, and to take responsibility for stitching them back into the correct order. However, this tolerance is limited. If a receiver receives a segment with a sequence number that is "too" out of order then the receiver discards the segment.

What counts as "too" out-of-order is, for most segments, determined by the receiver's *TCP window size*. As we will soon see, `RST` segments are subject to even more restrictive rules.

### TCP window size

Imagine an ancient, early-1990s computer, connected to a modern gigabit fibre network. The lightning-quick network will feed data to the venerable computer at a high speed, but once a TCP segment arrives at the computer it still has to be received and processed properly. When TCP data arrives at a computer it is temporarily stored in the computer's *TCP buffer* while the computer processes data that arrived ahead of it. However, this buffer has a finite size. If the receiver is unable to keep up with the volume of data that the network is feeding it then the buffer will fill up. Once the buffer is completely full the computer will have no choice but to drop any excess data on the floor. The sender will have to re-send its data once the computer has freed up some spare space in its buffer. It doesn't matter how fast a network can send data if the receiver can't keep up.

Alternatively, imagine that your over-zealous friend is mailing you a torrent of letters faster than you can read them. You have a certain amount of buffer space inside your mailbox, but once your mailbox fills up then the overflow letters will spill out onto the floor, where they will be eaten by foxes and other critters. Your friend will have to re-send the eaten letters once you've had time to catch up with their earlier missives. Sending too many letters or too much data when the recipient is unable to process them is a pure waste of energy and bandwidth.

How much data is too much? How does a sender know when to send more data and when to hold back? This is where the *TCP window size* comes in. A receiver's window size is the maximum number of unacknowledged bytes that a sender may have in flight to that receiver at any one time. During the handshake that is performed at the start of a TCP connection, each party tells the other their window size. A computer with a large buffer might declare a large window size in order to maximize throughput; a computer with a small buffer might be forced to declare a small one, sacrificing some amount of speed to minimize the chance that its buffer fills up and large numbers of TCP segments have to be re-sent.

To see how windows work in practice, remember that every TCP segment must be explicitly acknowledged by its recipient in order for its sender to consider it to have arrived safely. Suppose that a receiver advertises a window size of 100,000. The sender fires off 100,000 bytes. By the time it has sent the 100,000th byte, the receiver has sent `ACK`s for 10,000 of those bytes. This means that there are 90,000 bytes still un-acked. Since the window size is 100,000, this leaves 10,000 bytes that the sender can send before it has to wait for more `ACK`s. After sending 10,000 extra bytes the sender will have hit the limit of 100,000 un-acknowledged bytes. The sender will therefore have to wait and not send any more data (apart from re-sending segments that it believe may be lost) until it receives more `ACK`s.

[TODO-pic]

This hard limit on the amount of data that may be in-flight at a given time allows us to calculate the maximum sequence number that can be sent. The maximum sequence number that a sender can send is:

```
max_seq_no = max_acked_seq_no + window_size
```

`max_acked_seq_no` is the maximum sequence number that the receiver has sent an `ACK` for. It is the maximum sequence number that the sender knows that the receiver has received successfully. In order to ensure that there are never more than `window_size` unacknowledged bytes in-flight at any one time, the sender should in no circumstances send a segment with a sequence number greater than the `max_seq_no` limit. In fact, the TCP specification decrees that if a receiver receives a segment with a sequence number greater than this limit, it should ignore it. For example, if the highest sequence number that a receiver has acknowledged is 150,000, and its window size is 30,000, then the receiver will accept any segment with a sequence number between 150,000 and (150,000 + 30,000 = 180,000). However, it will completely ignore those with a sequence number outside this range. Note that we are still ignoring the possibility of *selective `ACK`s*, which we touched on briefly at the start of this post.

These are the rules governing acceptable sequence numbers for most TCP segments. However, as previously noted, the restrictions on `RST` segments are even stricter. Whereas normal segments are accepted if they have a sequence number anywhere in the receiver's window of expection, `RST` packets are only accepted if they have a sequence number exactly equal to that of the next segment that the receiver expects.

Consider once again our previous example, in which the highest acknowledged sequence number was 150,000. In order to be accepted, a `RST` packet must have a sequence number of exactly 160,000 (TODO). If the receiver receives a `RST` segment with a sequence number that is inside its window of expectation but is not this exact value, it responds with a "challenge `ACK`". The challenge `ACK` contains the value of the next sequence number that the receiver expects, and the idea behind it is that it allows the sender to resend its `RST` with the correct sequence number inserted. The receiver tells the sender that the `RST` had the wrong sequence number, but that it is prepared to accept a new `RST` segment that is labelled with the correct sequence number.

Before 200X (TODO), the TCP protocol did not impose these additional restrictions on `RST` segments. `RST` segments were accepted or rejected according to the same rules as any other segment. However, it was noted[TODO] that this made *blind TCP reset attacks* too easy. In a blind TCP reset attack, the attacker has no visibility into the traffic being exchanged by their victims. This means that they have no information whatsoever concerning the appropriate sequence number to give their spoofed `RST` segments, and instead have to blast out as many segments as they can, enumerating the space of possible sequence numbers.

The protocol's previously overly-permissive acceptance of `RST` segments made such brute-force attacks too powerful. The attacker didn't have to guess the sequence number exactly; instead they only had to guess a value somewhere within the receiver's window size. To counter this, the rules for when a receiver should accept a `RST` segment were changed to the more restrictive rules described above. With the new rules in force, blind TCP reset attacks require sending out millions of segments, making them intractable. See RFC XXX (TODO) for more details.

## Executing a TCP reset attack against ourselves

We now know everything that we need to know in order to fully understand and execute a TCP reset attack against ourselves.

We need to:

* Watch (or *sniff*) the network traffic between our two victims
* Choose a TCP segment with the `ACK` flag enabled and read the sequence number that it is acknowledging
* Craft a spoofed TCP segment with the `RST` flag enabled and a sequence number equal to the ack-ed sequence number from the intercepted segment
* Send the spoofed segment to our target, hopefully terminating our victims' TCP connection

We can execute a TCP attack against ourselves using a single computer talking to itself through `localhost`. We will begin by setting up a TCP connection between two terminal windows. Then we will send some traffic over this connection, sniff the traffic using an attack program, and finally send spoofed TCP `RST` packets to trick our terminal windows into breaking their connection.

### 1. Setup a TCP connection between two terminal windows

In this example we will setup our TCP connection using a tool called [`netcat`][netcat], which comes pre-installed on many operating systems. In our first terminal window we start a server that listens for incoming TCP connections on `localhost` on port `8000`:

```
nc 127.0.0.1 8000
```

In our second terminal window we connect to this server:

```
nc -nvl 8000
```

These two terminal windows should now have a TCP connection established between them. Try typing some words into one window - the data should be sent over the TCP connection and appear in the other window.

### 2. Sniff the traffic

We use a popular Python library called `scapy` to write an attack program that sniffs the traffic sent over our TCP connection. This means that our attack program reads the data exchanged between our client and server terminal windows, without being part of the connection.

The code below sniffs traffic on our connection and prints it to the terminal. The most important part of the code to understand is the call to `scapy`'s `sniff` method at the bottom of the file:

```python
t = sniff(
    iface=your_iface,
    count=50,
    prn=send_reset(seq_jitter=20),
    lfilter=is_packet_tcp_client_to_server(localhost_ip, localhost_server_port, localhost_ip))
```

This call tells `scapy` to listen on the `lo0` localhost network interface. It also tells `scapy` to filter out all packets that aren't part of a connection between two localhost IPs, on the expected port. This filtering is necessary because many other programs running on our machine use the `lo0` interface, and we want to ignore those that aren't part of our experiment. The `prn` parameter gives `scapy` a function to run each matching packet through, which at the moment simply logs it to the terminal. Finally, the `count` parameter gives the number of packets we want `scapy` to sniff before returning.

The effect of this call is to sniff packets on the `lo0` interface, and to log details about all packets that are part of our TCP connection.

### 3. Send spoofed `RST` packets

With a connection established and a program able to sniff the TCP segments passing through it, all that remains is for us to modify the program to execute the TCP reset attack by sending spoofed `RST` segments.

To do so, we modify the `prn` function that `scapy` calls on packets matching our `lfilter` function. Now, instead of simply logging a matching packet, we inspect it, pull off the necessary parameters, and use those parameters to construct and send a `RST` packet.

For example, suppose we intercept a segment going from `(src_ip, src_port)` to `(dst_ip, dst_port)`. It has the `ACK` flag set, an `ack` value of 100,000, and a window size of 30,000. We craft a `RST` packet as follows:

First, the destination and source IPs and ports are switched. This is because our packet is a response to the intercepted packet. Our packet's source should be the original packet's destination, and vice-versa. 

Next we turn on the TCP segment's `RST` flag. This flag is what indicates that the segment is a `RST`. Then we set the sequence number to be the `ack` number from the packet that we intercepted. The `ack` number indicates the next sequence number that the sender expects to receive, so we set ours accordingly. Finally, we call `scapy`'s `send` method to send the segment to the original packet's source.

```python
TODO
```

To execute the attack in full, we use the `netcat` commands from step1 to set up our TCP connection between our two terminal windows. Then we run our attack program in a third window. The next time we send data across the TCP connection by typing into one of the `netcat` sessions, the session that we typed into should be abruptly closed. We should see that our attack program has logged details of the `RST` segment that caused this mischief.

The attack is complete!

----

Follow the steps above and try the attack out for yourself. See what happens if you add or subtract 1 from the sequence number of the `RST` packet. Convince yourself that it needs to be *exactly* equal to the `ack` value of the intercepted packet.

Download Wireshark and use it to listen on the `lo0` interface while you are executing the attack. This will allow you to see all the details of every TCP segment exchanged over the connection, including the spoofed `RST`. Use the filter `ip.src == 127.0.0.1 && ip.dst == 127.0.0.1 && tcp.port == 8000` to filter out extraneous traffic from other programs.

Conclusion blah blah blah TODO. 
















This means that receivers can receive segments in the wrong order and then use their sequence number to stitch them back together correctly. 

If a segment arrives with a sequence number far 





When two machines open a TCP connection with each other, they perform a *handshake*. This is a ritual of negotiating the details of the connection. One of these details is 





The internet is often described as running on "TCP over IP". 









Using a standard networking protocol called *Border Gateway Protocol* (BGP), the government instructs Chinese internet service providers (ISPs) to block (or *null route*) all traffic to these IP addresses.

In DNS pollution, the government once again manipulates internet standards. The internet doesn't understand domains like `robertheaton.com`; instead, it only understands IP addresses like `104.18.32.191`. When a computer wants to communicate with a domain it has to first translate the domain to an IP address. It does so using the Domain Name System, or DNS. It sends a *DNS request* to a *DNS server* asking "what is the IP address for `robertheaton.com`


In this series of blog posts, we will learn about the core purpose and mechanics of TCP. Armed with this knowledge we will analyze, in detail, how a TCP reset attack works. We will perform one on ourselves.


A "TCP connection" doesn't mean that there's a set of switches kept open for you. Just means that sequence numbers are being kept track of





 It does this at the *gateway routers* at the edge of the country's network. These are the routers where traffic leaves China and heads out onto the rest of the internet. It also has numerous wiretaps throughout the Chinese national network.



As we've discussed, sequence numbers are determined by incrementing a randomly-generated initial sequence number. Since these initial sequence numbers are generated randomly, it is difficult for attackers to know what sequence number to give their `RST` segments so that they are accepted.

This problem is reduced for an attacker who is able to monitor the contents of the target TCP connection between their two victims. Sequence numbers (like all TCP/IP headers) are not encrypted, and can be read by anyone with access to the traffic. Such an attacker can read sequence numbers, read which segments have been acknowledged, and attempt to use this information to craft a `RST` segment with a sequence number that will be accepted by its target. Attackers without visibility into the traffic (for example, if I decided to try to disrupt your connection with Facebook without any visibility into your network) have no idea what sequence number to use. They can still attempt a *blind TCP reset attack* by using entirely random sequence numbers, and in fact such an attack would have worked quite well until a mitigation was put into place in 20XX-TODO as part of RFC123-TODO.
